{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"borer Efficient CBOR and JSON (de)serialization for Scala.","title":"borer"},{"location":"/index.html#borer","text":"Complete borer supports all CBOR and JSON features, incl. “over long” integers, 16-bit half-precision floats, BigInteger and BigDecimal, custom tags and “simple values”. Lightweight borer has zero external dependencies and its code is relatively compact. Fast borer features DOM-less pull-parsers with one-element look-ahead and is designed for a good tradeoff between performance and usability. It supports stream parsing (in constant memory, even for very large files) and consistently outperforms most other serialization libraries targeting CBOR or JSON that are available to Scala developers. Flexible borer tries hard to make integration into your applications environment as seamless as possible. The type-class based design makes a lot of aspects deeply and easily customizable. Also, since borer offers a unified API for both, CBOR and JSON, it’s very easy to provide “bilingual” REST APIs that can consume and produce both formats interchangibly. Debuggable borer offers convenient in-depth logging of the encoding/decoding process that is very helpful for debugging serialization issues, especially when working with a binary format like CBOR. Scala JS All borer modules (except for borer-compat-akka) support scala.js.","title":"borer"},{"location":"/design-principles.html","text":"","title":"Basic Design Principles and Limitations"},{"location":"/design-principles.html#basic-design-principles-and-limitations","text":"borer’s goal is to provide a highly efficient (de)serialization layer between some data model defined in Scala and CBOR and/or JSON as storage/network formats. borer performs this task in a very direct way, without relying on some Abstract Syntax Tree (AST, also called Document Object Model (DOM)) as intermediate structure.\nAs such it doesn’t offer any facilities for pre- or post-processing the serialized data, like manipulating the JSON structure, filtering or augmenting nodes, or the like.\nAlso, it doesn’t rely on reflection in any way. All information about the types to encode and decode must be statically available at the encoding/decoding point. With the exception of sealed ADT hierarchies (which are supported out of the box with the borer-derivation module) this means that you need to define yourself how to represent type information of abstract types on the wire!\nAnother design principle has been to implement borer’s core module without relying on Scala macros or depending on any external libraries. This should make borer easily maintainable for the foreseeable future and reduces its weight as a dependency of your applications (which can be especially important with scala.js).\n(Note: The borer-derivation module does rely on macros for deriving codec type classes, but its use is completely optional.)","title":"Basic Design Principles and Limitations"},{"location":"/getting-started.html","text":"","title":"Getting Started"},{"location":"/getting-started.html#getting-started","text":"","title":"Getting Started"},{"location":"/getting-started.html#modules","text":"borer consists of these modules:\nborer-core, the actual core logic (no dependencies) borer-derivation, (semi-)automatic codec derivation for case classes and ADTs (no dependencies, relies on macros) borer-compat-akka, support for akka.util.ByteString and akka-http (un)marshalling (has a provided dependency on akka-actor, akka-stream and akka-http) borer-compat-cats, support for popular cats data structures from the cats.data._ package (has a provided dependency on cats-core) borer-compat-circe, seamless integration with circe codecs (has a provided dependency on circe) borer-compat-scodec, support for scodec.bits.ByteVector (has a provided dependency on scodec)","title":"Modules"},{"location":"/getting-started.html#installation","text":"The artifacts for borer live on Maven Central and can be tied into your project like this:\nsbt libraryDependencies ++= Seq(\n  \"io.bullet\" %% \"borer-core\" % \"1.6.3\",\n  \"io.bullet\" %% \"borer-derivation\" % \"1.6.3\",\n  \"io.bullet\" %% \"borer-compat-akka\" % \"1.6.3\",\n  \"io.bullet\" %% \"borer-compat-circe\" % \"1.6.3\",\n  \"io.bullet\" %% \"borer-compat-scodec\" % \"1.6.3\"\n) Maven <dependencies>\n  <dependency>\n    <groupId>io.bullet</groupId>\n    <artifactId>borer-core_2.13</artifactId>\n    <version>1.6.3</version>\n  </dependency>\n  <dependency>\n    <groupId>io.bullet</groupId>\n    <artifactId>borer-derivation_2.13</artifactId>\n    <version>1.6.3</version>\n  </dependency>\n  <dependency>\n    <groupId>io.bullet</groupId>\n    <artifactId>borer-compat-akka_2.13</artifactId>\n    <version>1.6.3</version>\n  </dependency>\n  <dependency>\n    <groupId>io.bullet</groupId>\n    <artifactId>borer-compat-circe_2.13</artifactId>\n    <version>1.6.3</version>\n  </dependency>\n  <dependency>\n    <groupId>io.bullet</groupId>\n    <artifactId>borer-compat-scodec_2.13</artifactId>\n    <version>1.6.3</version>\n  </dependency>\n</dependencies> Gradle dependencies {\n  implementation \"io.bullet:borer-core_2.13:1.6.3\"\n  implementation \"io.bullet:borer-derivation_2.13:1.6.3\"\n  implementation \"io.bullet:borer-compat-akka_2.13:1.6.3\"\n  implementation \"io.bullet:borer-compat-circe_2.13:1.6.3\"\n  implementation \"io.bullet:borer-compat-scodec_2.13:1.6.3\"\n}\nborer is available for Scala 2.12 and 2.13 as well as scala.js.","title":"Installation"},{"location":"/borer-core/index.html","text":"","title":"borer-core"},{"location":"/borer-core/index.html#borer-core","text":"Encoding and Decoding Types Supported Out-of-the-Box Encoding and Decoding Custom Types Case Classes Transforming Existing Encoders / Decoders “Manual” Construction Nullable and Default NullOptions StringNumbers and StringBooleans ByteStringArrayCodecs Input, Output, ByteAccess Input Output ByteAccess JSON Specifics Base Encodings for Binary Data When (not) to use borer for JSON Comparison with other Scala JSON Libraries JSON Performance Document Object Model (DOM) Debugging","title":"borer-core"},{"location":"/borer-core/encoding-and-decoding.html","text":"","title":"Encoding and Decoding"},{"location":"/borer-core/encoding-and-decoding.html#encoding-and-decoding","text":"Encoding a value to a plain Array[Byte]:\nCBOR copysourceimport io.bullet.borer.Cbor\n\nval value = List(\"foo\", \"bar\", \"baz\") // example value\n\nval bytes: Array[Byte] =\n  Cbor.encode(value).toByteArray // throws on error\n\nbytes ==> hex\"9f63666f6f636261726362617aff\" JSON copysourceimport io.bullet.borer.Json\n\nval value = List(\"foo\", \"bar\", \"baz\") // example value\n\nval bytes: Array[Byte] =\n  Json.encode(value).toByteArray // throws on error\n\n// or immediately decode the bytes into a String:\n\nval json: String =\n  Json.encode(value).toUtf8String // throws on error\n\njson ==> \"\"\"[\"foo\",\"bar\",\"baz\"]\"\"\"\nbytes ==> json.getBytes(\"UTF8\")\nDecoding a plain Array[Byte] back to a certain type:\nCBOR copysourceimport io.bullet.borer.Cbor\n\nval list: List[String] =\n  Cbor.decode(bytes).to[List[String]].value // throws on error JSON copysourceimport io.bullet.borer.Json\n\nval list: List[String] =\n  Json.decode(bytes).to[List[String]].value // throws on error\nIf you don’t want BORER to throw exceptions you can use the following variants to give you a Try instead:\nCBOR copysourceimport io.bullet.borer.Cbor\n\nval encoded: Try[Array[Byte]] =\n  Cbor.encode(value).toByteArrayTry\n\nval decoded: Try[List[String]] =\n  Cbor.decode(bytes).to[List[String]].valueTry JSON copysourceimport io.bullet.borer.Json\n\nval encoded: Try[Array[Byte]] =\n  Json.encode(value).toByteArrayTry\n\nval decoded: Try[List[String]] =\n  Json.decode(bytes).to[List[String]].valueTry\nOr, if you prefer encoding/decoding to an Either instance:\nCBOR copysourceimport io.bullet.borer._\n\nval encoded: Either[Borer.Error[Output], Array[Byte]] =\n  Cbor.encode(value).to[Array[Byte]].resultEither\n\nval decoded: Either[Borer.Error[Input.Position], List[String]] =\n  Cbor.decode(bytes).to[List[String]].valueEither JSON copysourceimport io.bullet.borer._\n\nval encoded: Either[Borer.Error[Output], Array[Byte]] =\n  Json.encode(value).to[Array[Byte]].resultEither\n\nval decoded: Either[Borer.Error[Input.Position], List[String]] =\n  Json.decode(bytes).to[List[String]].valueEither\nAdditionally borer offers even more top-level API calls that give you the respective Output or Input instances either directly or wrapped in Try or Either. Check the sources of the central borer API entry point for more info.","title":"Encoding and Decoding"},{"location":"/borer-core/supported-types.html","text":"","title":"Types Supported Out-of-the-Box"},{"location":"/borer-core/supported-types.html#types-supported-out-of-the-box","text":"borer comes with built-in encoding and decoding support for arbitrary combinations of the following types:\nBoolean, Char, Byte, Short Int, Long, Float, Double and their boxed counterparts Null String Array[Byte] java.math.BigInteger, java.math.BigDecimal and their scala wrappers BigInt and BigDecimal Option[T] Array[T] M[T] <: Iterable[T] M[A, B] <: Map[A, B] Iterator[T] (encoding only!) Either[A, B] (with import io.bullet.borer.Codec.ForEither.default) Tuple1[A] … Tuple22[A, B, ... V]\nAll these type are encoded to exactly one CBOR or JSON data item (which may of course be an array or map consisting of other, nested data items.)","title":"Types Supported Out-of-the-Box"},{"location":"/borer-core/custom-types.html","text":"","title":"Encoding and Decoding Custom Types"},{"location":"/borer-core/custom-types.html#encoding-and-decoding-custom-types","text":"In order to encode some custom type T you’ll have to implicitly provide an Encoder[T]:\ntrait Encoder[T] {\n  def write(w: Writer, value: T): w.type\n}\nSimilarly, for decoding of T you’ll have to implicitly provide Decoder[T]:\ntrait Decoder[T] {\n  def read(r: Reader): T\n}\nMany times, when encoding and decoding must be available for a type, it’s easier to supply just a single implicit for T, rather than two. As an alternative to providing a separate Encoder[T] as well as a Decoder[T] you can also provide a Codec[T], which is defined like this:\nfinal case class Codec[T](encoder: Encoder[T], decoder: Decoder[T])\nEncoders and Decoders can be implicitly “unpacked” from a Codec.\nThere are several ways to provide such encoders, decoders or codecs for your custom types. The following sections outline the alternatives.\nNote In order to not hinder composability Codecs should only ever be supplied, never consumed. So, if you write an Encoder, Decoder or Codec for a generic type, which itself requires implicitly available encoders and/or decoders for certain type parameters (like Encoder.forOption, for example) then you should never require an implicitly available Codec[T], but rather an Encoder[T] and Decoder[T] separately. For example, you should say: // ok: require `Encoder`/`Decoder` instances and supply a `Codec`\nimplicit def forOption[T: Encoder :Decoder]: Codec[Option[T]] = ...\n rather than // bad: requiring a `Codec` (here: as a Context Bound)\nimplicit def forOption[T: Codec]: Codec[Option[T]] = ...","title":"Encoding and Decoding Custom Types"},{"location":"/borer-core/custom-types.html#case-classes","text":"The best way to concisely generate codecs for case classes is borer’s Derivation module.\nIf for some reason you cannot or don’t want to use macro-based codec derivation and array-based codecs are sufficient for you use case then there is a macro-less solution available with the borer-core alone:\nIf T is a case class with at most 22 members then an Encoder[T] and/or Decoder[T] can be concisely provided by via the unapply / apply methods of the T companion object:\ncopysourceimport io.bullet.borer.{Codec, Decoder, Encoder}\n\ncase class Color(name: String, value: Int)\n\nimplicit val encoder = Encoder.from(Color.unapply _)\nimplicit val decoder = Decoder.from(Color.apply _)\n\n// alternative: provide an Encoder and Decoder at the same time\nimplicit val codec = Codec(\n  Encoder.from(Color.unapply _),\n  Decoder.from(Color.apply _)\n)\nThe codecs created in this way always encode a case class instance to a single CBOR/JSON data item: an array with the length corresponding to the case classes arity and the member encodings forming the array elements. There is one exception though: In order to increase encoding efficiency unary case classes, with only one parameter, have their single member written directly, without a wrapping single-element array.\nThe encoding strategy is thus identical to the one produced by the macro-derived ArrayBasedCodecs.\nIf you would like your case classes to be encoded in a more JSON-esque way, as maps with each member being keyed by its member name, the MapBasedCodecs from the borer-derivation module are your only option, short of Manual Construction.","title":"Case Classes"},{"location":"/borer-core/custom-types.html#transforming-existing-encoders-decoders","text":"If your type can somehow be constructed from or deconstructed to another type that an Encoder or Decoder is already available for, you can rely on the contramap and map methods available on Encoders / Decoders:\ncopysourceimport io.bullet.borer.{Decoder, Encoder}\n\nclass Person(val name: String)\n\n// have `Person` be encoded as a simple CBOR/JSON text data item\nimplicit val personEncoder = Encoder.forString.contramap[Person](_.name)\nimplicit val personDecoder = Decoder.forString.map(new Person(_))","title":"Transforming Existing Encoders / Decoders"},{"location":"/borer-core/custom-types.html#construction","text":"For full flexibility of how your type T is to be encoded in CBOR/JSON you can of course also write the respective Encoder[T] / Decoder[T] manually. This is done by explicitly defining how your type is to be written to a Writer and read from a Reader:\ncopysourceimport io.bullet.borer.{Decoder, Encoder}\n\nclass Person(val name: String, val age: Int)\n\nimplicit val encoder: Encoder[Person] = Encoder { (writer, person) =>\n  writer\n    .writeArrayOpen(2)\n    .writeString(person.name)\n    .writeInt(person.age)\n    .writeArrayClose()\n}\n\nimplicit val decoder: Decoder[Person] = Decoder { reader =>\n  val unbounded = reader.readArrayOpen(2)\n  val person = new Person(\n    reader.readString(),\n    reader.readInt()\n  )\n  reader.readArrayClose(unbounded, person)\n}\nOn the encoding side the Writer gives you a number of different methods for writing CBOR/JSON primitives, while the Reader offers their counterparts on the decoding side. The next section has some more details on how to work with these two types.\nWhile this low-level way of defining the encoding/decoding logic is the most powerful it also requires a little more care. For performance reasons both the Writer and Reader types are mutable abstractions, which means that the order in which you call their methods matters a lot.\nCaution Also, very importantly, when deciding on an encoding logic for any type (i.e. how to represent the type with the available CBOR/JSON primitives) make sure to always encode it to exactly one data item! (Unless you know exactly, what you are doing.) All built-in encoders and decoders, e.g. for case classes, arrays, maps, etc., always assume that any object is written to exactly data item. So, if you need to write several values, wrap them in an array or map! And rather than writing no value at all write some kind of placeholder, like null, undefined or an empty array or map!\nTo illustrate the point: The default codec for Option[T] for example encodes Some[T] to a single element array holding the encoding of T, and None to a zero-element (empty) array.\nWhile borer (by default) verifies that the CBOR/JSON created by your application is indeed valid and will thus catch any mistakes you made in this regard eventually, debugging structural problems can be a bit tedious since the error will often only be recognizable at the very end of the encoding or decoding process. Check out the section on Debugging for more info how borer can support you in debugging (de)serialization issues.","title":"“Manual” Construction"},{"location":"/borer-core/custom-types.html#reader-and-writer","text":"All pre-defined Encoders and Decoders, as well as the ones you might write yourself, describe how to encode or decode and object by operating on a Writer or Reader, respectively.\nThe Writer (sources here) contains a largish number of methods (like writeInt, writeString or writeArrayHeader) that more or less directly write the respective data item to the output. The Reader (sources here) contains the respective counterparts (like readInt, readString or readArrayHeader).\nThe Writer and Reader operate directly on the respective Output and Input data “streams” and simply cause the respective low-level “primitive” to be written or read. This means, that the logic working with them has to have at least a basic understanding of the rules governing how these primitives can be or must be combined in order to produce valid output.\nFor example, an “indefinite-length array” (in CBOR terminology) is written by first calling writer.writeArrayStart(), then writing all the elements (recursively descending into any nested structures) and finally “closing” the array with writer.writeBreak().\nOn the reading side this is mirrored by first having to call reader.readArrayStart(), then reading all the elements (recursively decoding nested structures) and finally consuming the “closing” with reader.readBreak().\nWhile borer implements validation logic (enabled by default), which verifies the structural integrity of all produced and consumed data, there are no static (type-level, i.e. compile-time) checks that catch you, when you forget to write or read the BREAK primitive at the end!\nWhen consuming CBOR data during decoding the Reader gives you one-element look-ahead. This means that you can “see” the kind of the next data item (primitive) that is available before reading it, which is often very helpful.\nFor example, here is an potential Decoder[Either[String, Int]]:\ncopysourceimport io.bullet.borer.Decoder\n\nimplicit val eitherStringIntDecoder: Decoder[Either[String, Int]] =\n  Decoder { reader =>\n    if (reader.hasString) Left(reader.readString())\n    else if (reader.hasInt) Right(reader.readInt())\n    else reader.unexpectedDataItem(expected = \"`String` or `Int`\")\n  }","title":"Reader and Writer"},{"location":"/borer-core/nullable-and-default.html","text":"","title":"Nullable and Default"},{"location":"/borer-core/nullable-and-default.html#nullable-and-default","text":"One question that frequently arises when dealing with JSON, and to a limited extend CBOR as well, is how to deal with null values.\nnull values differ from missing members (see also Map-Based Codecs) in that the value for an element is indeed present, but is null.\nborer handles this case in a properly typed fashion: If your data model allows for certain members to have a null encoding that you would like to treat specially the member’s type should be wrapped with Nullable, e.g. Nullable[String]. In combination with the simple type class Default[T], which provides the capability to supply default values for a type T, the pre-defined Encoder and Decoder for Nullable[T] will be able to translate null values to the respective default value and back.\nExample:\ncopysourceimport io.bullet.borer.{Json, Nullable}\nimport io.bullet.borer.derivation.MapBasedCodecs._\n\ncase class Dog(age: Int, name: Nullable[String])\n\nimplicit val dogCodec = deriveCodec[Dog]\n\nJson\n  .decode(\"\"\"{ \"age\": 4, \"name\": null }\"\"\" getBytes \"UTF8\")\n  .to[Dog]\n  .value ==>\nDog(age = 4, name = \"\") // the `Default[String]` provides an empty String","title":"Nullable and Default"},{"location":"/borer-core/nullable-and-default.html#nulloptions","text":"Sometimes it’s convenient to map “nullable” fields to Options, i.e. null to None and non-null to Some. This can easily be done with this import:\nimport io.bullet.borer.NullOptions._\nHere is how NullOptions are implemented:\ncopysource/**\n  * In order to enable an alternative [[Option]] codec, which\n  * encodes `None` to `null` and `Some` to an unwrapped value\n  * you can import the members of this object with\n  *\n  * {{{\n  * import io.bullet.borer.NullOptions._\n  * }}}\n  */\nobject NullOptions {\n\n  implicit def encoder[T: Encoder]: Encoder[Option[T]] =\n    Encoder {\n      case (w, Some(x)) => w.write(x)\n      case (w, None)    => w.writeNull()\n    }\n\n  implicit def decoder[T: Decoder]: Decoder[Option[T]] =\n    Decoder { r =>\n      if (r.tryReadNull()) None\n      else Some(r.read[T]())\n    }\n}\nNote At first glance it might seem that NullOptions could actually be the default way to encode a value of type Option[T] since null appears as the “natural” construct in JSON / CBOR to represent “no value”. However, NullOptions have a serious drawback which makes them unsuitable as the generally preferred representation strategie for Option[T]: They are unsound as in “they don’t compose”. Consider the type Option[Option[T]]. With NullOptions its value Some(None) would serialize to null, which would then deserialize to None rather than Some(None), which is unsound as it violates the basic “roundtrip requirement” deserialize(serialize(x)) == x.","title":"NullOptions"},{"location":"/borer-core/StringNumbers.html","text":"","title":"StringNumbers and StringBooleans"},{"location":"/borer-core/StringNumbers.html#stringnumbers-and-stringbooleans","text":"Some external APIs, especially JSON-based ones, encode certain or all numbers, booleans and even null as string values, even if the respective value could be represented as a native JSON or CBOR number, boolean or null.\nIn order to make integration with these kind of services easy borer comes with predefined encoders and decoders for numbers, booleans and null that you can “enable” with simple imports and which then take precedence over the default encoders and decoders.\nThis is how they are enabled:\ncopysourceimport io.bullet.borer.{Decoder, Encoder}\n\nimport Encoder.StringNumbers._  // enables number-as-strings encoding\nimport Encoder.StringBooleans._ // enables booleans-as-strings encoding\nimport Encoder.StringNulls._    // enables null-as-strings encoding\n\nimport Decoder.StringNumbers._  // enables number-as-strings decoding\nimport Decoder.StringBooleans._ // enables booleans-as-strings decoding\nimport Decoder.StringNulls._    // enables null-as-strings decoding\nAs always these imports are “active” throughout the complete scope in which they are visible.\nHere is an example demonstrating how to encode numbers and booleans as strings:\ncopysourceimport io.bullet.borer.{Encoder, Json}\nimport io.bullet.borer.derivation.MapBasedCodecs._\n\ncase class Dog(age: Int, male: Boolean, name: String)\n\nimport Encoder.StringNumbers._  // enables number-as-strings encoding\nimport Encoder.StringBooleans._ // enables booleans-as-strings encoding\n\nimplicit val dogCodec = deriveCodec[Dog]\n\nval dog = Dog(2, false, \"Lolle\")\n\n// note how the Int and Boolean are rendered as JSON strings\nJson.encode(dog).toUtf8String ==>\n\"\"\"{\"age\":\"2\",\"male\":\"false\",\"name\":\"Lolle\"}\"\"\"\nDecoding works correspondingly.","title":"StringNumbers and StringBooleans"},{"location":"/borer-core/ByteStringArrayCodecs.html","text":"","title":"ByteStringArrayCodecs"},{"location":"/borer-core/ByteStringArrayCodecs.html#bytestringarraycodecs","text":"CBOR has a very compact encoding for byte arrays because binary data are “first-class”. While JSON itself has no such built-in support for binary representation Base Encodings can provide an often acceptable work-around for the problem. (See also this chapter for more information about borer’s out-of-the-box support for Base Encodings!)\nSometimes, however, the need arises to encode larger amounts of data as efficiently as binary data, even if they are not immediately represented as byte arrays, for example arrays of primitive numbers such as:\nArray[Short] Array[Int] Array[Long] Array[Float] Array[Double]\nBy default borer will encode these types like any other array, which can add quite a bit of overhead, especially in the case of JSON.\nIn order to allow for more efficient encodings (as well as faster encoding and decoding processes) borer provides special codecs for these array types that you can “enable” with one of these two imports:\nimport io.bullet.borer.ByteStringArrayCodecs.BigEndian._ import io.bullet.borer.ByteStringArrayCodecs.LittleEndian._\nWith one of these imports in place an Array[Int] for example will be encoded as a raw byte array, with each Int value being represented as four bytes (in the respective byte order). Conversion to and from byte arrays is done as efficiently as the platform allows.\nAlso, the ByteStringArrayCodecs are compatible with custom byte array encoders (like the Base Encoders).","title":"ByteStringArrayCodecs"},{"location":"/borer-core/supporting-typeclasses.html","text":"","title":"Input, Output, ByteAccess"},{"location":"/borer-core/supporting-typeclasses.html#input-output-byteaccess","text":"In order to allow for seamless integration in all kinds of application environments borer abstracts over decoding input, encoding output as well as general “chunks of bytes” with three additional type classes Input[T], Output[T] and ByteAccess[T].","title":"Input, Output, ByteAccess"},{"location":"/borer-core/supporting-typeclasses.html#input","text":"For decoding borer happily consumes any type for which an Input.Provider[T] is implicitly available, which is responsible for constructing an Input from or around T:\ncopysource/**\n  * Responsible for converting an instance of [[T]]\n  * to a respective [[Input]] instance.\n  */\ntrait Provider[T] {\n  type Bytes\n  def byteAccess: ByteAccess[Bytes]\n  def apply(value: T): Input[Bytes]\n}\nCurrently borer comes with predefined Input implementations for these types:\nArray[Byte] java.nio.ByteBuffer java.io.InputStream java.io.File akka.util.ByteString (with the borer-compat-akka module) scodec.bits.ByteVector (with the borer-compat-scodec module) Iterator[T], provided that there is an Input.Provider[T] available implicitly\nThe latter is a great way to consume large input in a streaming fashion, without having to load everything into memory at once. The FromFileInput, for example, relies on it to parse large files as an iteration of chunks.\nThe Input trait isn’t particularly hard to implement, especially since it merely has to support single-pass access to the underlying bytes with minimal buffering and without random access.","title":"Input"},{"location":"/borer-core/supporting-typeclasses.html#output","text":"On the encoding side borer can either produce any type T for which an Output.ToTypeProvider[T] is available, or “push” the output into a value of type T if an Output.ToValueProvider[T] is available:\ncopysource/**\n  * Responsible for providing an Output that produces instances of [[T]].\n  */\ntrait ToTypeProvider[T] {\n  type Out <: Output { type Result = T }\n  def apply(bufferSize: Int, allowBufferCaching: Boolean): Out\n}\n\n/**\n  * Responsible for providing an Output that outputs into the given value [[T]].\n  */\ntrait ToValueProvider[T] {\n  type Out <: Output { type Result = T }\n  def apply(value: T, bufferSize: Int, allowBufferCaching: Boolean): Out\n}\nCurrently borer comes with predefined Output implementations for these types:\nArray[Byte] java.nio.ByteBuffer java.io.OutputStream (to a an existing instance) java.io.File (to a an existing instance) akka.util.ByteString (with the borer-compat-akka module) scodec.bits.ByteVector (with the borer-compat-scodec module)\nThe Output trait isn’t hard to implement as it simply writes out all bytes in a single pass.\nHere are a few examples to illustrate the top-level output API:\ncopysourceimport io.bullet.borer.Cbor\n\nval value = List(\"foo\", \"bar\", \"baz\") // example value\n\n// encodes into a new byte array instance,\n// relies on the `Output.ToTypeProvider[Array[Byte]]` type class instance\nCbor.encode(value).to[Array[Byte]].result ==> hex\"9f63666f6f636261726362617aff\"\n\n// same as above but slightly more convenient\nCbor.encode(value).toByteArray ==> hex\"9f63666f6f636261726362617aff\"\n\n// encodes into an existing file,\n// relies on the `Output.ToValueProvider[File]` type class instance\nval file = new java.io.File(filename)\nCbor.encode(value).to(file).result ==> file","title":"Output"},{"location":"/borer-core/supporting-typeclasses.html#byteaccess","text":"Unfortunately Scala (and the whole JVM eco-system) has no single, versatile abstraction for a “chunk of bytes” that fits the needs of all applications. In order to remain open to the preferences of the application borer also abstracts over “chunks of bytes” by allowing the use of any type T, for which a ByteAccess[T] is available.\nCurrently borer comes with predefined ByteAccess implementations for these types:\nArray[Byte] java.nio.ByteBuffer akka.util.ByteString (with the borer-compat-akka module) scodec.bits.ByteVector (with the borer-compat-scodec module)","title":"ByteAccess"},{"location":"/borer-core/JSON-specifics.html","text":"","title":"JSON Specifics"},{"location":"/borer-core/JSON-specifics.html#json-specifics","text":"Since the CBOR data item primitives are a super-set of what is available in JSON, or, said differently, everything in JSON has a counterpart in CBOR, it’s not hard for borer to also support encoding to and decoding from JSON.\nFrom borer’s point of view JSON is simply a slightly different binary format that only supports a subset of the CBOR data primitives. Like CBOR borer encodes and decodes JSON in a single pass, UTF-8 encoding and decoding to and from raw bytes on the fly.\nAll higher-level abstractions (i.e. Writer, Reader, Encoder, Decoder, Codec, etc.) are essentially agnostic to the (de)serialization target format. Nevertheless, the Writer and Reader types do have a target member, which enables custom logic to discriminate between the two variants, if required. Since the underlying JSON renderer will throw exceptions on attempts to write data primitives that are not supported in JSON (like CBOR Tags, for example), this is sometimes necessary to efficiently support both formats.\nFor example, in order to write an empty array in the most efficient way to both CBOR and JSON using only the most low-level data items one would use this approach:\ncopysourceimport io.bullet.borer.Writer\n\ndef writeEmptyArray(w: Writer): w.type =\n  if (w.writingJson) w.writeArrayStart().writeBreak()\n  else w.writeArrayHeader(0) // fixed-sized Arrays are not supported in JSON\nBut on a slightly higher level the Writer also gives you a way to write arrays (and maps) without having distinguish between CBOR and JSON yourself:\ncopysourceimport io.bullet.borer.Writer\n\ndef writeAsUnaryArray(w: Writer, s: String): w.type =\n  w.writeArrayOpen(1) // automatically chooses the most efficient\n    .writeString(s)\n    .writeArrayClose() // way to write an array of size one\nAs long as you rely on the somewhat higher-level parts of the Reader and Writer APIs or construct your (de)serialization purely logic from borer’s built-in or (and/or derived) Encoders and Decoders, your application will support both CBOR and JSON at the same time without any special casing whatsoever.","title":"JSON Specifics"},{"location":"/borer-core/JSON-specifics.html#base-encodings-for-binary-data","text":"One big drawback of JSON over CBOR is that JSON doesn’t provide any “first-class” representation of binary data. This is typically worked around by mapping binary data to a “Base Encoding”, e.g. the ones defined by RFC 4648.\nIn order to give your application an easy and flexible way to integrate with other systems borer supports a number of base encodings out of the box, specifically:\nbase16 base32 base32hex base32crockford z-base32 base64 base64url\nThe default JSON encoding for Array[Byte] is base64.\nIn order to switch to a different base encoding in a particular scope define the a pair of implicits as in this example:\ncopysourceimport io.bullet.borer.{Decoder, Encoder, Json}\nimport io.bullet.borer.encodings.BaseEncoding\n\nval binaryData = hex\"DEADBEEF\"\n\n// Json.encode(binaryData).toByteArray or\nJson.encode(binaryData).toUtf8String ==> \"\"\"\"3q2+7w==\"\"\"\"\n\n// we need to explicitly define the encoder as well as the decoder\n// in order to \"override\" the defaults for Array[Byte] on either side\nimplicit val byteArrayEncoder = Encoder.forByteArray(BaseEncoding.zbase32)\nimplicit val byteArrayDecoder = Decoder.forByteArray(BaseEncoding.zbase32)\n\nJson.encode(binaryData).toUtf8String ==> \"\"\"\"54s575a\"\"\"\"","title":"Base Encodings for Binary Data"},{"location":"/borer-core/JSON-specifics.html#when-not-to-use-for-json","text":"Since borer treats JSON as a binary format and reads/writes from/to raw bytes it isn’t optimized for consuming or producing Strings as input or output. (Strings have to first be UTF-8 encoded in order to be readable by borer.) So, if you need to frequently consume String input other JSON libraries will likely perform better. Also, if you need to manipulate the JSON structures in any way between (de)serializing from/to the wire and from/to your data model then borer will not help you and a DOM/AST-based JSON solution (like Circe) will likely be the better choice.\nHowever, if all you need is an efficient way to convert raw network- or disk-bytes holding UTF-8 encoded JSON to and from your data model types, with no (or few) dependencies and maybe even with the option to target CBOR with no additional work required from your side, then borer should be a good choice.\nNote Since borer doesn’t really work with String and Char, but rather raw bytes only, it also doesn’t support encoding to a “pretty”, i.e. nicely formatted, JSON representation. borer always outputs JSON in the most compact form. (It can, of course, read “pretty” JSON documents without any issue.)","title":"When (not) to use borer for JSON"},{"location":"/borer-core/JSON-specifics.html#comparison-with-other-scala-json-libraries","text":"(Additions, corrections, improvement suggestions very welcome, especially to this section!)\nCirce AST/DOM- and type-class-based design\nvery mature allows for extensive DOM-manipulation many integration option already available compatible with scala.js\ndepends on cats-core type class derivation can be slow (at compile time) borer decodes JSON more than twice as fast no CBOR support\nspray-json AST/DOM- and type-class-based design\nzero dependencies\npre-historic, clunky type class design essentially unmaintained no direct support for case classes w/ more than 22 members no type class derivation for ADTs borer decodes JSON more than 3 times as fast not compatible with scala.js no CBOR support\nµPickle pull-style, type class-based design\nzero dependencies optional DOM also supports MessagePack compatible with scala.js\nno support for case classes w/ more than 64 members no support for manual (no-macro) codec construction borer decodes JSON more than 4 times as fast no CBOR support\nJackson Scala Java implementation with a Scala add-on\nvery mature good performance\nno type class-based API several non-Scala dependencies not compatible with scala.js borer decodes JSON about 20% faster\nJsoniter Scala pull-style, type class-based design\nzero dependencies very high performance (about 15% faster JSON decoding than borer) support out of the box for all Scala collections and java.time.* classes highly configurable has scala.js support\nvery low-level core API entirely macro-based high-level API no pre-defined AST/DOM no CBOR support","title":"Comparison with other Scala JSON Libraries"},{"location":"/borer-core/JSON-performance.html","text":"","title":"JSON Performance"},{"location":"/borer-core/JSON-performance.html#json-performance","text":"borer comes with a fast JSON parser optimized for modern superscalar 64-bit CPUs, which performs quite well when compared to other popular JSON libraries in the scala eco-system when it comes to transforming raw JSON-bytes into a case-class based data model.\nA benchmark against 18 real-world JSON data examples from a diverse set of sources shows that borer’s JSON parsing infrastructure outperforms Circe (for example) by more than a factor of two, on average:\nThis is the benchmark setup:\nTask Decode 18 files from raw JSON bytes into a respective case-class based data model generated with https://transform.now.sh/json-to-scala-case-class/ JMH Parameters -wi 10 -i 10 -t 4 -f 4 JVM Java HotSpot(TM) 64-Bit GraalVM EE 19.2.1 Memory Settings -Xms4096m -Xmx4096m Scala Version 2.12.10 Operating System Ubuntu 18.04.2 LTS CPU 2 x Intel Xeon E5-2665 2.4 - 3.1 GHz (Octa-core)\nThe benchmarks SBT sub project contains everything you need to run the benchmarks yourself. This SBT command will produce a JSON file holding all results:\njmh:run io.bullet.borer.benchmarks.* -wi 10 -i 10 -t 4 -f 4 -foe true -rf json -rff results/my_results.json\nNote This “full” benchmark will run for more than 4 days!\nSince interpreting the results can be a bit tedious borer comes with some simple analysis logic that can be invoked with the benchmarkResults SBT command. It will show you a synthesis of all benchmark results currently living in the benchmarks/results folder.\nWarning The benchmarks/results folder already contains the results of the last “official” benchmarking runs. (here) When you run your own benchmarks you should first remove these “official” .json files since benchmark results are not comparable when run on non-identical machines!","title":"JSON Performance"},{"location":"/borer-core/DOM.html","text":"","title":"Document Object Model (DOM)"},{"location":"/borer-core/DOM.html#document-object-model-dom-","text":"While borer’s core design is DOM-less, writing directly to and reading directly from the respective stream of CBOR/JSON data items, it is sometimes convenient to nevertheless have access to an object structure that mirrors the structure of a CBOR/JSON document as closely as possible. (Many JSON-libraries solely rely on such an intermediate “AST” structure for their encoding and decoding operations.)\nFor such cases borer provides you with a simple “DOM” ADT (see the respective source file here), which you can use like this:\nCBOR copysourceimport io.bullet.borer.Cbor\nimport io.bullet.borer.Dom._\n\nval dom = MapElem.Sized(\n  \"foo\" -> ArrayElem.Sized(IntElem(42), StringElem(\"rocks\")),\n  \"bar\" -> DoubleElem(26.8)\n)\n\nval encoded = Cbor.encode(dom).toByteArray\n\nencoded ==> hex\"A263666F6F82182A65726F636B7363626172FB403ACCCCCCCCCCCD\"\n\nval decoded = Cbor.decode(encoded).to[Element].value\n\ndecoded ==> dom JSON copysourceimport io.bullet.borer.Dom._\nimport io.bullet.borer.Json\n\nval dom = MapElem.Unsized(\n  \"foo\" -> ArrayElem.Unsized(IntElem(42), StringElem(\"rocks\")),\n  \"bar\" -> DoubleElem(26.8)\n)\n\nval encoded = Json.encode(dom).toByteArray\n\nnew String(encoded, \"UTF8\") ==> \"\"\"{\"foo\":[42,\"rocks\"],\"bar\":26.8}\"\"\"\n\nval decoded = Json.decode(encoded).to[Element].value\n\ndecoded ==> dom\nAny CBOR or JSON document can be deserialized into a io.bullet.borer.Dom.Element, which can then be queried or transformed in any way, and potentially written back to CBOR or JSON.\nAs such, the borer DOM can also be used to transform JSON to CBOR, e.g. like this:\ncopysourceimport io.bullet.borer.{Cbor, Json}\nimport io.bullet.borer.Dom._\n\nimport scala.util.Try\n\ndef jsonToCbor(json: String): Try[Array[Byte]] =\n  Json\n    .decode(json getBytes \"UTF8\")\n    .to[Element]\n    .valueTry\n    .flatMap(dom => Cbor.encode(dom).toByteArrayTry)\n\njsonToCbor(\"\"\"{\"foo\":[42,\"rocks\"],\"bar\":26.8}\"\"\").get ==>\nhex\"BF63666F6F9F182A65726F636B73FF63626172FB403ACCCCCCCCCCCDFF\"","title":"Document Object Model (DOM)"},{"location":"/borer-core/debugging.html","text":"","title":"Debugging"},{"location":"/borer-core/debugging.html#debugging","text":"With CBOR being a binary format debugging problems can sometimes be a bit more difficult than with text-based formats like JSON, which are immediately human-readable.\nIn order to help debug problems with encoding or decoding, independently of whether they are caused by your own application code or invalid / unexpected input, you can easily switch on logging of the encoding or decoding process with the .withPrintLogging() modifier.\nFor example, this snippet:\ncopysourceimport io.bullet.borer.Cbor\nimport io.bullet.borer.Codec.ForEither.default\n\nval value = Map(\n  \"foo\" -> Left(42),\n  \"bar\" -> Right(Vector(\"For\", \"the\", \"King!\"))\n)\nval encoded = Cbor.encode(value).toByteArray\nval decoded =\n  Cbor\n    .decode(encoded)\n    .withPrintLogging() // just insert this line to enable logging\n    .to[Map[String, Either[Int, Vector[String]]]]\n    .value\nproduces this logging output to the console:\n1: {\n    1/2: \"foo\"\n    1/2: -> {\n        1/1: 0\n        1/1: -> 42\n    1/2: }\n    2/2: \"bar\"\n    2/2: -> {\n        1/1: 1\n        1/1: -> [\n            1/3: \"For\"\n            2/3: \"the\"\n            3/3: \"King!\"\n        1/1: ]\n    2/2: }\n1: }\n2: END\nwhich makes it very easy to see, what exactly the decoding input consists of. Also, in case of any exception the log will break off exactly at the point where the exception got thrown, which is often a great help in locating the problem.","title":"Debugging"},{"location":"/borer-derivation/index.html","text":"","title":"borer-derivation"},{"location":"/borer-derivation/index.html#borer-derivation","text":"Derivation Basics Semi-Automatic Derivation Fully-Automatic Derivation Array-Based Codecs Map-Based Codecs Default ADT Encoding Alternative “Flat” Encoding of ADTs Default Values Customized Member Keys CompactMapBasedCodecs Type IDs Derivation FAQ Custom Overrides Explicit Upcasts Recursive ADTs","title":"borer-derivation"},{"location":"/borer-derivation/basics.html","text":"","title":"Derivation Basics"},{"location":"/borer-derivation/basics.html#derivation-basics","text":"In order to have borer automatically derive Encoders and/or Decoders for your custom types you need to first include the borer-derivation module as a dependency. See the Getting Started chapter for details.\nOnce that is done you need to pick one of two available encoding strategies:\nArray-Based Codecs or Map-Based Codecs.\nAs the name implies the difference between these two encoding strategies lies in the type of the underlying structure that class instances are serialized to.\nThe Array-Based Codecs render class instances into arrays where each member is identified merely via its positional index. This is more efficient than Map-Based encoding, with regard to both runtime performance and storage requirements.\nThe Map-Based Codecs on the other hand render class members as named map entries, which has the the benefit that the wire format is more descriptive, not dependent on ordering and even allows for missing and default members.","title":"Derivation Basics"},{"location":"/borer-derivation/basics.html#semi-automatic-derivation","text":"Once you have the respective import for Array-Based or Map-Based Codecs derivation in scope the following macros for semi-automatic derivation are available:\nderiveEncoder[T], which derives an Encoder[T] deriveDecoder[T], which derives a Decoder[T] deriveCodec[T], which derives a Codec[T], i.e. an Encoder[T] as well as a Decoder[T]\nThese methods work for all T that are are either case classes, sealed traits or sealed abstract classes.\nSee the chapters on Array-Based Codecs or Map-Based Codecs for examples.","title":"Semi-Automatic Derivation"},{"location":"/borer-derivation/basics.html#fully-automatic-derivation","text":"In addition to semi-automatic derivation, which will only ever derive a typeclass instance for a single type, borer also provides the following macros for fully-automatic derivation of encoder/decoder typeclasses for whole ADT hierarchies, i.e. sealed traits or sealed abstract classes and all their sub-types:\nderiveAllEncoders[T], which derives an Encoder[T] deriveAllDecoders[T], which derives a Decoder[T] deriveAllCodecs[T], which derives a Codec[T], i.e. an Encoder[T] as well as a Decoder[T]\nTo understand what these macros do consider this simple example:\ncopysourcesealed trait Animal\ncase class Dog(age: Int, name: String)                      extends Animal\ncase class Cat(weight: Double, color: String, home: String) extends Animal\ncase class Fish(color: String)                              extends Animal\ncase object Yeti                                            extends Animal\nWith semi-automatic derivation you’d have to explicitly call a derivation macro for each sub-type individually:\ncopysourceimport io.bullet.borer.derivation.MapBasedCodecs._\n\nimplicit val animalCodec = {\n  implicit val dogCodec  = deriveCodec[Dog]\n  implicit val catCodec  = deriveCodec[Cat]\n  implicit val fishCodec = deriveCodec[Fish]\n  implicit val yetiCodec = deriveCodec[Yeti.type]\n  deriveCodec[Animal]\n}\nThis gives you full control but can be a bit tedious for larger ADT hierarchies.\nFully-automatic derivation on the other hand lets you reduce the boilerplate to a minimum by generating the calls to the derivation macro for each ADT sub-type automatically, so you only need to write a single line:\ncopysourceimport io.bullet.borer.derivation.MapBasedCodecs._\n\nimplicit val animalCodec = deriveAllCodecs[Animal]","title":"Fully-Automatic Derivation"},{"location":"/borer-derivation/array-based.html","text":"","title":"Array-Based Codecs"},{"location":"/borer-derivation/array-based.html#array-based-codecs","text":"Array-Based Codec derivation is enabled with this import:\ncopysourceimport io.bullet.borer.derivation.ArrayBasedCodecs._\nHere is an example:\ncopysourceimport io.bullet.borer.Json\nimport io.bullet.borer.derivation.key\nimport io.bullet.borer.derivation.ArrayBasedCodecs._\n\nsealed trait Animal\ncase class Cat(weight: Double, color: String, home: String) extends Animal\n@key(\"TheDog\") case class Dog(age: Int, name: String)       extends Animal\n@key(42) case class Mouse(tail: Boolean)                    extends Animal\n\nimplicit val dogCodec   = deriveCodec[Dog]\nimplicit val catCodec   = deriveCodec[Cat]\nimplicit val mouseCodec = deriveCodec[Mouse]\n\nimplicit val animalCodec = deriveCodec[Animal]\n\nval cat   = Cat(8.5, \"grey\", \"sofa\")\nval dog   = Dog(2, \"Rex\")\nval mouse = Mouse(tail = true)\n\nJson.encode(cat).toUtf8String ==> \"\"\"[8.5,\"grey\",\"sofa\"]\"\"\"\nJson.encode(dog).toUtf8String ==> \"\"\"[2,\"Rex\"]\"\"\"\nJson.encode(mouse).toUtf8String ==> \"true\"\n\ndef encodeAnimal(animal: Animal) = Json.encode(animal).toUtf8String\n\nencodeAnimal(cat) ==> \"\"\"[\"Cat\",[8.5,\"grey\",\"sofa\"]]\"\"\"\nencodeAnimal(dog) ==> \"\"\"[\"TheDog\",[2,\"Rex\"]]\"\"\"\nencodeAnimal(mouse) ==> \"\"\"[42,true]\"\"\"\nWith these codecs case classes are written to CBOR/JSON as simple arrays, unless the case class has arity 1. If the case class has only a single member, the derived codec directly writes the member without wrapping it in an array.\nAn Abstract Data Type (ADT) is encoded as an array of length two, with the first element holding the type ID and the second holding the instance’s encoding (i.e. an array or single element).\nCheck out the chapter on Type IDs for more info on type IDs and how to customized them.","title":"Array-Based Codecs"},{"location":"/borer-derivation/map-based.html","text":"","title":"Map-Based Codecs"},{"location":"/borer-derivation/map-based.html#map-based-codecs","text":"Map-based codec derivation is enabled with this import:\ncopysourceimport io.bullet.borer.derivation.MapBasedCodecs._\nWith these codecs case classes are encoded as CBOR/JSON maps with the member name as key, i.e. the popular “standard” way for serializing to and from JSON.\nHere is an example relying on map-based codecs:\ncopysourceimport io.bullet.borer.Json\nimport io.bullet.borer.derivation.MapBasedCodecs._\n\ncase class Foo(int: Int, string: String)\ncase class Bar(foo: Foo, d: Double)\n\nimplicit val fooCodec = deriveCodec[Foo]\nimplicit val barCodec = deriveCodec[Bar]\n\nval foo = Foo(int = 42, string = \"yeah\")\nval bar = Bar(foo, d = 1.234)\n\n// Json.encode(bar).toByteArray or\nJson.encode(bar).toUtf8String ==>\n\"\"\"{\"foo\":{\"int\":42,\"string\":\"yeah\"},\"d\":1.234}\"\"\"","title":"Map-Based Codecs"},{"location":"/borer-derivation/map-based.html#default-adt-encoding","text":"The default encoding for ADT super-types is a single-entry map, with the key being the type id and the value becoming the encoding of the actual ADT subtype instance.\nFor example, a Dog instance of the following ADT:\ncopysourcesealed trait Animal\ncase class Dog(age: Int, name: String)                      extends Animal\ncase class Cat(weight: Double, color: String, home: String) extends Animal\ncase class Fish(color: String)                              extends Animal\ncase object Yeti                                            extends Animal\nwould be encoded to JSON like this:\n{ \"Dog\" :\n  {\n    \"age\":2,\n    \"name\":\"Rex\"\n  }\n}\nHere is the code (Note the explicit upcast to the ADT super-type Animal!):\ncopysourceimport io.bullet.borer.Json\n\nval animal: Animal = Dog(2, \"Rex\")\n\n// Json.encode(animal).toByteArray or\nJson.encode(animal).toUtf8String ==> \"\"\"{\"Dog\":{\"age\":2,\"name\":\"Rex\"}}\"\"\"","title":"Default ADT Encoding"},{"location":"/borer-derivation/map-based.html#alternative-encoding-of-adts","text":"The default encoding for ADTs (single-entry maps) cleanly separates the encoding of the ADT super-type from the encoding of the ADT sub-types by introducing a dedicated “envelope” layer holding the type ID in an efficient form. This encoding can be written, stored and read in a very efficient manner and is therefore recommended for all application where you have full control over the both ends of the encoding “channel”.\nHowever, especially when interoperating with other systems, it is sometimes required to support another encoding style, which carries the type ID in a special map entry, e.g. like this:\n{\n  \"_type\": \"Dog\",\n  \"age\":2,\n  \"name\":\"Rex\"\n}\nThis alternative ADT encoding can be switched to by making the result of a call to AdtEncodingStrategy.flat() implicitly available:\ncopysourceimport io.bullet.borer.{AdtEncodingStrategy, Json}\nimport io.bullet.borer.derivation.MapBasedCodecs._\n\n// this enables the flat ADT encoding\nimplicit val flatAdtEncoding =\n  AdtEncodingStrategy.flat(typeMemberName = \"_type\")\n\nimplicit val animalCodec = deriveAllCodecs[Animal]\n\nval animal: Animal = Dog(2, \"Rex\")\n\n// Json.encode(animal).toByteArray or\nJson.encode(animal).toUtf8String ==> \"\"\"{\"_type\":\"Dog\",\"age\":2,\"name\":\"Rex\"}\"\"\"\nWhile this “flat” ADT encoding has the benefit that the encoding can be decoded into the ADT super-type or the respective ADT sub-type (provided that the decoder simply ignores surplus members, as borer does) it also has a number of significant drawbacks:\nIt requires all ADT sub-types to be encoded to maps, i.e. it violates separation of concerns between the super- and sub-types. This can be annoying, e.g. when unary case classes could otherwise be stored more efficiently in an “unwrapped” form, e.g. with the CompactMapBasedCodecs. It conflates two conceptually well separated and distinct name spaces: The one of the envelope (ADT super-type) and the one of the sub-type. This always leads to the risk of name collisions, which gives rise to type member names like $type or __type or the like, which make the hacky “smell” of the approach even more visible. Due the unordered nature of JSON objects/maps it makes efficient single-pass parsing impossible in the general case, since the information, how to interpret an object’s members (the type of the object) might be delayed until the very end of the input file. This requires either potentially unbounded caching or a second pass over the input. borer’s approach is the former (caching) with a configurable bound on the cache size (triggering an exception, when exceeded). It’s slightly less efficient storage-wise (depending on the length of the typeMemberName).\nFor these reasons borer’s default ADT encoding relying on single-element maps is generally the preferred choice.","title":"Alternative “Flat” Encoding of ADTs"},{"location":"/borer-derivation/map-based.html#default-values","text":"Map-based codecs support missing and extra members.\nBy default a member whose value matches the default value is not written to the output at all during encoding. This can be changed by bringing a customized io.bullet.borer.derivation.DerivationConfig instance into scope.\nDuring decoding the type’s Decoder will use the potentially defined default value for all missing members, e.g.:\ncopysourceimport io.bullet.borer.Json\nimport io.bullet.borer.derivation.MapBasedCodecs._\n\ncase class Dog(age: Int, name: String = \"<unknown>\")\n\nimplicit val dogCodec = deriveCodec[Dog]\n\nJson\n  .decode(\"\"\"{ \"age\": 4 }\"\"\" getBytes \"UTF8\")\n  .to[Dog]\n  .value ==> Dog(age = 4)\nExtra members (i.e. map keys present in the encoding but not defined as a case class member or @key) are simply ignored.\nAlso, Encoder/Decoder type classes can implement the Encoder.DefaultValueAware / Decoder.DefaultValueAware trait in order to alter their behavior in the presence of a default value.\nThis is used, for example, by the pre-defined encoder and decoder for Option[T], which change their encoding/decoding strategy, if a None default value is defined for a case class member. In this case the optional value will only be written if it’s defined (and then without any wrapping structure). If the option is undefined nothing is written at all.\nHere is the actual implementation of borer’s Encoder for Option:\ncopysourceimplicit def forOption[T: Encoder]: Encoder.DefaultValueAware[Option[T]] =\n  new Encoder.DefaultValueAware[Option[T]] {\n\n    def write(w: Writer, value: Option[T]) =\n      value match {\n        case Some(x) => w.writeToArray(x)\n        case None    => w.writeEmptyArray()\n      }\n\n    def withDefaultValue(defaultValue: Option[T]): Encoder[Option[T]] =\n      if (defaultValue eq None) {\n        new Encoder.PossiblyWithoutOutput[Option[T]] {\n          def producesOutputFor(value: Option[T]) = value ne None\n          def write(w: Writer, value: Option[T]) =\n            value match {\n              case Some(x) => w.write(x)\n              case None    => w\n            }\n        }\n      } else this\n  }\nCorrespondingly, during decoding the presence of the member yields a defined option instance holding the decoded value and None, if the member is missing.\nThis behavior should match the intution of what an Option[T] case class member would behave like when written to a JSON representation.","title":"Default Values"},{"location":"/borer-derivation/map-based.html#customized-member-keys","text":"borer supports customizing the name of case class members in the encoding with the same @key annotation, that is also used for custom ADT type-ids (see Array-Based Codec and the @key sources here for more info).\nSimply annotate a case class member do provide a custom name:\ncopysourceimport io.bullet.borer.Json\nimport io.bullet.borer.derivation.key\nimport io.bullet.borer.derivation.MapBasedCodecs._\n\ncase class Dog(age: Int, @key(\"the-name\") name: String)\n\nimplicit val dogCodec = deriveCodec[Dog]\n\nJson.encode(Dog(1, \"Lolle\")).toUtf8String ==>\n\"\"\"{\"age\":1,\"the-name\":\"Lolle\"}\"\"\"","title":"Customized Member Keys"},{"location":"/borer-derivation/map-based.html#compactmapbasedcodecs","text":"As a slight variant of the MapBasedCodecs borer also provides CompactMapBasedCodecs which are identical except for the encoding of unary case classes, i.e. case classes with only a single member.\nThe CompactMapBasedCodecs encode them in an unwrapped form, i.e. directly as the value of the single member. The name of the sole case class therefore doesn’t appear in the encoding at all.","title":"CompactMapBasedCodecs"},{"location":"/borer-derivation/type-ids.html","text":"","title":"Type IDs"},{"location":"/borer-derivation/type-ids.html#type-ids","text":"When encoding Abstract Data Types (ADTs), i.e. top types of sealed type hierarchies like Animal in this example:\ncopysourcesealed trait Animal\ncase class Dog(age: Int, name: String)                      extends Animal\ncase class Cat(weight: Double, color: String, home: String) extends Animal\ncase class Fish(color: String)                              extends Animal\ncase object Yeti                                            extends Animal\nthe encoder needs to somehow transfer the information to the decoder, which of the defined sub-types to decode into. In the context of the example ADT above, when Json.decode(encoding).to[Animal] is called the decoder needs to know, whether the encoding holds a Dog, a Cat or any of the other (well-defined) sub-types of Animal.\nThis is done through a “Type ID”, which is a String or number that uniquely identifies each ADT sup-type.\nBy default borer will use a sub-type’s short class name as a (textual) type ID, i.e. \"Dog\" would be the type id of Dog instances and \"Cat\" would be the same for the Cat type.\nIf you want to customize this you can use the @key annotation to do so. Check out the @key sources here for more info on this.","title":"Type IDs"},{"location":"/borer-derivation/faq.html","text":"","title":"Derivation FAQ"},{"location":"/borer-derivation/faq.html#derivation-faq","text":"Fully-automatic derivation (via the deriveAll... macros) comes with a few special cases/gotchas that are detailed on this page.","title":"Derivation FAQ"},{"location":"/borer-derivation/faq.html#custom-overrides","text":"Fully-automatic derivation of encoders/decoders for ADTs allows for providing custom codecs for a subsets of the type hierarchy. If a implicit typeclass for a certain sub-type is already available at the deriveAll... macro call site then this implicit will be used rather than a new (and potentially conflicting) one generated.\nExample:\ncopysourcesealed trait Animal\ncase class Dog(age: Int, name: String)                      extends Animal\ncase class Cat(weight: Double, color: String, home: String) extends Animal\ncase class Fish(color: String)                              extends Animal\ncase object Yeti                                            extends Animal\ncopysourceimport io.bullet.borer.{Codec, Json}\nimport io.bullet.borer.derivation.MapBasedCodecs._\n\n// custom codec only for `Fish`\nimplicit val fishCodec = Codec.bimap[Int, Fish](_ => 0, _ => Fish(\"red\"))\n\n// let borer derive the codecs for the rest of the Animal ADT\nimplicit val animalCodec = deriveAllCodecs[Animal]\n\nval animal: Animal = Fish(\"blue\")\n\nJson.encode(animal).toUtf8String ==> \"\"\"{\"Fish\":0}\"\"\"\nIf you provide a custom codec for a whole abstract branch of the ADT hierarchy then borer will offload encoding and decoding of all sub-types of that branch to your custom codec.","title":"Custom Overrides"},{"location":"/borer-derivation/faq.html#explicit-upcasts","text":"Sometimes the interplay of typeclasses and ADTs can become a bit confusing, especially when explicit upcasts are required.\nThe important thing to remember is that borer’s typeclasses (Encoder[T], Decoder[T] and Codec[T]) are intentionally invariant in their type parameters. This means that they will only be found and used when the types match up exactly.\nWith this ADT, for example:\ncopysourcesealed trait Animal\ncase class Dog(age: Int, name: String)                      extends Animal\ncase class Cat(weight: Double, color: String, home: String) extends Animal\ncase class Fish(color: String)                              extends Animal\ncase object Yeti                                            extends Animal\nthe following codec definition gives you an Encoder[Animal] and a Decoder[Animal], nothing more, nothing less:\ncopysourceimport io.bullet.borer.derivation.MapBasedCodecs._\n\nimplicit val animalCodec = deriveAllCodecs[Animal]\nIt does not give you an Encoder[Dog] or a Decoder[Cat]! If you want codecs for specific ADT sub-types like Dog or Cat you need to define them in addition to the codec for the ADT super-type, e.g. like this:\ncopysourceimport io.bullet.borer.derivation.MapBasedCodecs._\n\nimplicit val dogCodec    = deriveCodec[Dog]\nimplicit val catCodec    = deriveCodec[Cat]\nimplicit val animalCodec = deriveAllCodecs[Animal]\nAn alternative would be to explicitly upcast a value of a more specific type to the ADT super type, e.g. like this:\ncopysourceimport io.bullet.borer.Json\n\nval animal: Animal = Dog(2, \"Rex\")\n\n// Json.encode(animal).toByteArray or\nJson.encode(animal).toUtf8String ==> \"\"\"{\"Dog\":{\"age\":2,\"name\":\"Rex\"}}\"\"\"\nHowever, note that the encoding of a Dog as an Animal is not the same as the encoding of the Dog itself!! The former includes the wrapping layer with the type-id while the latter doesn’t:\ncopysourceimport io.bullet.borer.Json\n\nval dog = Dog(2, \"Rex\")\nJson.encode(dog: Animal).toUtf8String ==> \"\"\"{\"Dog\":{\"age\":2,\"name\":\"Rex\"}}\"\"\"\nJson.encode(dog        ).toUtf8String ==> \"\"\"{\"age\":2,\"name\":\"Rex\"}\"\"\"\nThis is because the Decoder[Animal] needs to somehow receive the information which Animal type to decode into, while the Decoder[Dog] doesn’t, as it already knows the concrete target exactly.\nSo, while explicit upcasts are sometimes what you want there are also cases where they are not what you want. The exact target types of your (de)serializations depends on your specific use case and, as such, should be chosen carefully.","title":"Explicit Upcasts"},{"location":"/borer-derivation/faq.html#recursive-adts","text":"In most cases the codecs for non-generic ADTs are assigned to an implicit val so they don’t have to be recreated on every use. However, if the ADT is recursive the definition should be an implicit lazy val with an explicit type annotation instead, as in this example:\ncopysourceimport io.bullet.borer.Codec\nimport io.bullet.borer.derivation.MapBasedCodecs._\n\nsealed trait TreeNode\ncase object Leaf                                 extends TreeNode\ncase class Node(left: TreeNode, right: TreeNode) extends TreeNode\n\nimplicit lazy val codec: Codec[TreeNode] = deriveAllCodecs[TreeNode]","title":"Recursive ADTs"},{"location":"/borer-compat-akka.html","text":"","title":"borer-compat-akka"},{"location":"/borer-compat-akka.html#borer-compat-akka","text":"","title":"borer-compat-akka"},{"location":"/borer-compat-akka.html#bytestring-support","text":"The borer-core module by itself only knows how to encode to and decode from plain byte arrays (Array[Byte]) and a few other types (like java.nio.ByteBuffer, see the chapter on Input, Output, ByteAccess for full details).\nWhen you include the borer-compat-akka module as a dependency (see the Getting Started chapter for details) and\nimport io.bullet.borer.compat.akka._\nyou also get:\nfull “zero-copy” support for encoding to and decoding from akka.util.ByteString implicit codecs for akka.util.ByteString, akka.actor.ActorRef and akka.actor.typed.ActorRef[T]","title":"ByteString support"},{"location":"/borer-compat-akka.html#akka-http-un-marshalling","text":"In addition to ByteString support the borer-compat-akka also provides convenient marshallers and unmarshallers for HTTP entities.\nWhen you include the borer-compat-akka module as a dependency (see the Getting Started chapter for details) and\nimport io.bullet.borer.compat.akkaHttp._\nakka-http will transparently marshal to and from your custom domain model types:\ncopysourceimport akka.http.scaladsl.server.Route\nimport akka.http.scaladsl.server.Directives._\n\n// custom model for request and response content\nfinal case class MyRequest(foo: String)\nfinal case class MyResponse(importantValue: Int)\n\n// borer encoders/decoders for the custom model above\nimport io.bullet.borer.derivation.MapBasedCodecs._\n\nimplicit val myRequestDecoder  = deriveDecoder[MyRequest]\nimplicit val myResponseEncoder = deriveEncoder[MyResponse]\n\n// bring automatic (un) marshaller construction in scope\nimport io.bullet.borer.compat.akkaHttp._\n\n// route that unmarshalls to `MyRequest` and marshals to `MyResponse`\nval route: Route =\n  pathSingleSlash {\n    post {\n      entity(as[MyRequest]) { myRequest =>\n        complete {\n          MyResponse(myRequest.foo.length)\n        }\n      }\n    }\n  }\nBy default the Unmarshaller constructed by borer-compat-akka understand both CBOR and JSON with Content-Type application/cbor and application/json, respectively. The Marshaller also supports both formats and lets the client determine via HTTP content negotiation (i.e. the Accept header) , which one it prefers. If the client has no clear preference, i.e. it accepts both CBOR and JSON with equal “q-value” (preference weight) the Marshaller choses JSON by default. This default, however, can be configured to CBOR if needed.\n(Un)marshaller construction can be customized in various ways, e.g. with custom media types, and is also available for streams, i.e. to and from akka.stream.scaladsl.Source[T, _] rather than simply T. Check out the sources for full details.","title":"Akka Http (Un)Marshalling"},{"location":"/borer-compat-cats.html","text":"","title":"borer-compat-cats"},{"location":"/borer-compat-cats.html#borer-compat-cats","text":"The borer-compat-circe module provides default codecs for the following cats.data._ data structures from the cats cats-core package:\nChain[A] Ior[A, B] NonEmptyChain[T] NonEmptyList[T] NonEmptyMap[T] NonEmptySet[T] NonEmptyVector[T] Validated[A, B]","title":"borer-compat-cats"},{"location":"/borer-compat-cats.html#installation","text":"Include the borer-compat-cats module as a dependency (see the Getting Started chapter for details) and\nimport io.bullet.borer.compat.cats._\nWith this import in place borer will seamlessly encode and decode instances of the types listed above, provided that encoders and/or decoders are available for the respective “inner” types.","title":"Installation"},{"location":"/borer-compat-cats.html#encoding-strategies","text":"While the encoding strategies for most of the above data structures should be relatively straight-forward there are two types, for which there is no clear default encoding:\nIor[A, B] Validated[A, B]\nThe encodings implemented by borer-compat-circe aim for best time and space efficiency, not “readability”.\nOne easy way to optimize for self-describability rather than efficiency would be to rely on borer-derivation instead. Here is an example contrasting the difference:\ncopysourceimport cats.data.Ior\nimport io.bullet.borer.{Decoder, Encoder, Json}\n\nval value = List(\n  Ior.Left(1),\n  Ior.Right(\"foo\"),\n  Ior.Both(42, \"bar\")\n)\n\n// the Ior encoding of `borer-compat-circe` is optimized for efficiency\n{\n  import io.bullet.borer.compat.cats._\n\n  Json.encode(value).toUtf8String ==>\n  \"\"\"[[0,1],[1,\"foo\"],[2,42,\"bar\"]]\"\"\"\n}\n\n// the map-based codec generated by `borer-derivation` produces encodings\n// that self-describe better, but are less efficient space and time-wise\n{\n  implicit def iorCodec[A: Encoder: Decoder, B: Encoder: Decoder] =\n    MapBasedCodecs.deriveAllCodecs[Ior[A, B]]\n\n  Json.encode(value).toUtf8String ==>\n  \"\"\"[{\"Left\":{\"a\":1}},{\"Right\":{\"b\":\"foo\"}},{\"Both\":{\"a\":42,\"b\":\"bar\"}}]\"\"\"\n}\nSee the module sources for full details.","title":"Encoding Strategies"},{"location":"/borer-compat-circe.html","text":"","title":"borer-compat-circe"},{"location":"/borer-compat-circe.html#borer-compat-circe","text":"The borer-compat-circe module allows existing serialization code written against circe to be re-used for CBOR (de)serialization with minimal effort.","title":"borer-compat-circe"},{"location":"/borer-compat-circe.html#background","text":"circe is a mature JSON library that’s quite popular throughout the Scala ecosystem. Contrary to borer circe (de)serializes JSON not directly to/from the application-level model classes but models JSON documents with an intermediate-level AST (Abstract Syntax Tree) or DOM (Document Object Model). As shown in Figure 1 the Encoder / Decoder logic you write (or that circe derives for you) merely translates between your own types and this JSON AST/DOM.\nFigure 1. circe schematic\nborer on the other hand translates directly between your application-level model classes and the JSON document, without going through an intermediate AST/DOM representation (Figure 2).\nFigure 2. borer schematic\nThe borer-compat-circe module provides you with borer Encoder and Decoder type classes for circe’s AST node types, which allows you to combine both libraries as shown in Figure 3.\nFigure 3. borer-circe-compat schematic\nThe benefit of this construct is that existing encoding/decoding logic that so far has been only targeting JSON via circe can now also be used to target CBOR through borer. (Theoretically you could also use borer to target JSON with this construct but there wouldn’t be much point in doing so as circe can of course read and write its own AST nodes to and from JSON without borer’s help. Also, due to optimal integration between the layers, circe can likely do the job more efficiently that any external library ever could.)","title":"Background"},{"location":"/borer-compat-circe.html#usage","text":"When you include the borer-compat-circe module as a dependency (see the Getting Started chapter for details) you can write code such as this:\ncopysourceimport io.circe.{Decoder, Encoder} // NOTE: circe (!) Encoders / Decoders\nimport io.bullet.borer.Cbor\nimport io.bullet.borer.compat.circe._ // the borer codec for the circe AST\n\n// serializes a value to CBOR given that a circe `Encoder` is available\ndef serializeToCbor[T: Encoder](value: T): Array[Byte] =\n  Cbor.encode(value).toByteArray\n\n// serializes a value from CBOR given that a circe `Decoder` is available\ndef deserializeFromCbor[T: Decoder](bytes: Array[Byte]): T =\n  Cbor.decode(bytes).to[T].value\n\nval value = List(\"foo\", \"bar\", \"baz\") // example value\n\nval bytes = serializeToCbor(value)\nbytes ==> hex\"8363666f6f636261726362617a\"\n\ndeserializeFromCbor[List[String]](bytes) ==> value","title":"Usage"},{"location":"/borer-compat-circe.html#limitations","text":"Since JSON is merely a subset of CBOR and, as such, there are constructs in CBOR that do not directly map onto JSON not all CBOR documents can be easily decoded via a JSON deserialization layer such as the one provided by circe.\nMost importantly the following CBOR constructs do not readily and easily map onto JSON:\nundefined By default undefined values are decoded as null values. Raw Byte Strings By default raw byte strings are base64-encoded and passed to circe as JSON strings. Custom Simple Values By default an exception is thrown upon reading a custom CBOR “simple value”.\nThe behavior of the borer-circe-compat decoding logic can be customized, if necessary, by constructing the borer Decoder[io.circe.Json] with a custom call to io.bullet.borer.compat.circe.circeJsonAstDecoder(...).\nSee the module sources for full details.","title":"Limitations"},{"location":"/borer-compat-scodec.html","text":"","title":"borer-compat-scodec"},{"location":"/borer-compat-scodec.html#borer-compat-scodec","text":"The borer-core module by itself only knows how to encode to and decode from plain byte arrays (Array[Byte]).\nWhen you include the borer-compat-scodec module as a dependency (see the Getting Started chapter for details) and\nimport io.bullet.borer.compat.scodec._\nyou also get full “zero-copy” support for encoding to and decoding from scodec.bits.ByteVector as well as an implicit Encoder[ByteVector] and Decoder[ByteVector].","title":"borer-compat-scodec"},{"location":"/project/index.html","text":"","title":"Project Info"},{"location":"/project/index.html#project-info","text":"License Changelog References Sponsors","title":"Project Info"},{"location":"/project/license.html","text":"","title":"License"},{"location":"/project/license.html#license","text":"borer is released under the MPL 2.0, which is a simple and modern weak copyleft license.\nHere is the gist of the terms that are likely most important to you (disclaimer: the following points are not legally binding, only the license text itself is):\nIf you’d like to use borer as a library in your own applications borer is safe for use in closed-source applications. The MPL share-alike terms do not apply to applications built on top of or with the help of borer. You do not need a commercial license. The MPL applies to borer’s own source code, not your applications. If you’d like to contribute to borer You do not have to transfer any copyright. You do not have to sign a CLA. You can be sure that your contribution will always remain available in open-source form and will not become a closed-source commercial product (even though it might be used by such products!)\nFor more background info on the license please also see the official MPL 2.0 FAQ.","title":"License"},{"location":"/project/changelog.html","text":"","title":"Changelog"},{"location":"/project/changelog.html#changelog","text":"This is the current borer CHANGELOG:\ncopysourceVersion 1.6.3 (2020-11-06)\n--------------------------\n\n- reenabled build and publishing of `compat-circe-js` (#309)\n- fixed missing map member errors not honoring @key annotations (#312)\n- added `io.bullet.borer.derivation.DerivationConfig` (#311)\n\n\nVersion 1.6.2 (2020-10-08)\n--------------------------\n\n- compat-akka: add codecs for typed and classic ActorRefs (#208)\n- added ConcatEncoder (#289)\n- added Codec#withEncoder and Codec#withDecoder helpers\n- fixed ArrayIndexOutOfBoundsException when logging certain illegal input or output\n\n\nVersion 1.6.1 (2020-07-24)\n--------------------------\n\n- fixed StackOverflowError during encoding of BigInt/BigDecimal with `borer-compat-circe` (#269)\n- upgraded to Scala 2.12.12 / 2.13.3\n\n\nVersion 1.6.0 (2020-05-07)\n--------------------------\n\n- fixed decoding of non-primitive empty arrays (#227)\n- fixed derivation failing for tagged basic types\n- renamed `Default.get` to `Default.of`\n- split out `borer-deriver` module (so far undocumented)\n\n\nVersion 1.5.0 (2020-03-06)\n--------------------------\n\n- upgraded to ScalaJS 1.0.0\n- fixed buffer caching breaking nested encoding/decoding calls (#186)\n- added `borer-compat-cats` module (#191)\n- added `toByteArrayEither` and `toByteBufferEither` to `EncodingSetup.Api`\n- extended default encoder coverage to IterableOnce on 2.13 and TraversableOnce on 2.12 (#182)\n- renamed `Encoder.forIterable` to `Encoder.fromFactory`\n- improved the default encoding for `Either` (breaking change!)\n\n\nVersion 1.4.0 (2020-01-23)\n--------------------------\n\n- compat-akka: made marshalling target format preference configurable, switch default to JSON (#148)\n- fixed generation of stacked type ids in certain cases (#145)\n- fixed derived ADT decoders not reading type ids with certain mixed (String/Long) keys\n\n\nVersion 1.3.0 (2020-01-10)\n--------------------------\n\n- added fully automatic codec derivation for ADT hierarchies (#36)\n- added `Dom.Transformer` and `Dom.Transformer.ToJsonSubset` (#143)\n- added `CompactMapBasedCodecs`\n- removed `ArrayBasedCodecs.deriveUnaryXXX`\n- fixed `AdtEncodingStrategy.flat` defunct within certain wrapping elements (#142)\n- fixed `AdtEncodingStrategy.flat` broken for stacked ADTs (#144)\n\n\nVersion 1.2.1 (2019-12-05)\n--------------------------\n\n- improved JSON parsing performance (numbers by about 20%)\n\n\nVersion 1.2.0 (2019-12-04)\n--------------------------\n\n- added `borer-compat-circe` module (#113)\n- renamed `Decoder.forBigInteger` to `Decoder.forBigInt` for consistency\n- optimized JSON number parsing (#114, thanks to @plokhotnyuk)\n- fixed missing type bound on `Reader` type alias\n\n\nVersion 1.1.0 (2019-10-17)\n--------------------------\n\n- added `ByteStringArrayCodecs` for compact encoding of primitive arrays\n- added configurable ThreadLocal caching of char- and byte buffers (#78)\n- added support for reading directly from `InputStream` instances\n- enabled easy summoning of implicit Encoder/Decoder type classes (#77)\n- removed codec for `Either` from default implicit scope (#64)\n- renamed `Codec.implicitly` to `Codec.of`\n- improved akka-http compat (#62)\n- improved debug logging w/ ability to collapse long arrays/maps (#74)\n- simplified and cleaned-up top-level decoding- and `Input` API\n\n\nVersion 1.0.0 (2019-09-18)\n--------------------------\n\n- fixed two bugs in `AdtEncodingStrategy.flat` (#55)\n- added missing `ArrayBasedCodecs.deriveUnaryDecoder` (#54)\n- added automatic akka-http (un)marshaller construction\n- removed unused type parameter from EncodingSetup.Api\n\n\nVersion 0.11.1 (2019-08-13)\n---------------------------\n\n- fixed bug in ToByteBufferOutput (#52)\n- added encoders and decoders for \"as-string\" support of numbers, booleans and `null`\n- enabled custom codecs for basic types (#42)\n- further improved JSON parsing performance from byte arrays on JVM\n\n\nVersion 0.11.0 (2019-08-05)\n---------------------------\n\n- renamed `deriveXXXForUnaryCaseClass` to `deriveUnaryXXX`\n- added support for deriving codecs for case objects (#44)\n- added alternative \"flat\" encoding for ADTs (#38)\n- added selection of base encodings and default json codec for Array[Byte] (#40)\n- added helpers for target-specific codecs (#41)\n- added support for efficiently reading/writing char arrays\n- added missing `implicit` marker on `Codec.bimap`\n- made MapBased encoding skip basic members matching default value (#50)\n\n\nVersion 0.10.0 (2019-07-11)\n---------------------------\n\n- renamed method `bytes` (and friends) of `EncodingSetup#Sealed` to `result`\n- renamed `...Bool` to `...Boolean` everywhere, for consistency\n- removed `forCaseClass` macros from `core` module (use array-based derivation instead)\n- removed dependendy on magnolia\n- added alternative codec for Options (`NullOptions`) (#29)\n- added `Codec.bimap` (#25)\n- added support for directly reading from and writing to files\n- added support for reading from `Iterator[Input]`\n- added support for writing to `java.io.OutputStream`\n- improved codec derivation (#28, #31)\n- fixed key collision error when deriving codec for diamond ADT (#34)\n- extended `Decoder[Array[Byte]]` to also accept arrays (#15)\n- expanded benchmarking scope to also include upickle and jsoniter-scala\n- enabled unified Scala 2.12/2.13 cross-building\n- added paradox-based project website\n\n\nVersion 0.9.0 (2019-05-11)\n--------------------------\n\n- significantly improved JSON support on all fronts\n- changed map-based ADT encoding to single-element map\n- renamed `Encoder.compose` to `Encoder.contramap`\n- renamed @TypeId to @key, add support for custom map-key naming\n- fixed MapBasedCodecs to properly skip complex, extra data elements\n- fixed failing derivation for types with java annotations (#13)\n- fixed `Codec.forCaseClass` failing for generic case classes (#16)\n- added `Input`, `Output` and `ByteAccess` for `java.nio.ByteBuffer`\n- added configurable automatic conversion of integers to floating point values (#3)\n- added `Nullable[T]` and `Default[T]` abstraction\n- added special support for Options with default value `None`\n- added support for up to 128 case class members\n- hardened CBOR BigInteger and BigDecimal decoding (#8)\n- improved error position reporting\n- refactored `Input` design for more flexbility in supporting diverse input sources\n- internalized magnolia for various patches and Scala 2.13 support\n- added Scala 2.13 build (in the `scala2.13` branch, for now)\n\n\nVersion 0.8.0 (2019-04-13)\n--------------------------\n\n- added JSON support\n- simplified package structure (`io.bullet.borer.core.Cbor` is now `io.bullet.borer.Cbor`)\n- added @inline annotations to selected methods likely relevant for JS perf\n- flexibilized derived codecs to always accept indefinite-length as well\n- added comparative performance benchmarks (JSON only so far)\n- introduced \"NumberString\" abstraction for cleaner & faster JSON decoding\n- added missing pre-defined decoder for `HashMap[T]`\n- extended pre-defined `Array` codec to also support primitives (issue #2)\n- many other larger and smaller improvements across the whole library\n\n\nVersion 0.7.0 (2019-03-08)\n--------------------------\n\nborer-core:\n- simplified API by removing explicit `Bytes` type parameter from all abstractions\n- allowed for mixed `ByteAccess` in a single encoding / decoding run\n- various smaller improvements\n\nborer-akka & border-scodec:\n- added missing Codecs for akka ByteString and scodec ByteVector\n\n\nVersion 0.6.0 (2019-03-06)\n--------------------------\n\nborer-core:\n- refactored main entry-point DSL for clarity and convenience\n\nborer-core & borer-derivation:\n- Removed array-wrapping of derived codecs for `Product1` types\n\n\nVersion 0.5.1 (2019-03-05)\n--------------------------\n\nborer-derivation:\n- Fixed broken round-trip of `deriveCaseClassCodec` for zero- and single-member case classes\n\n\nVersion 0.5.0 (2019-03-04)\n--------------------------\n\nfirst public release","title":"Changelog"},{"location":"/project/references.html","text":"","title":"References"},{"location":"/project/references.html#references","text":"It’s always hard for any open-source project to keep track of who is using the software around the world.\nFor the individuals and organizations who’d like to make their using borer public we have created this page. If you’d like your organisation to be listed here (along with a backlink) please provide us with the following details:\nName of your organisation Homepage URL Short statement about how borer is used and/or your experiences (so far) with it (optional) Logo (optional)","title":"References"},{"location":"/project/sponsors.html","text":"","title":"Sponsors"},{"location":"/project/sponsors.html#sponsors","text":"The following companies and organisations have kindly agreed to supply the borer development team with free open-source licenses of their excellent development tools:\nJetBrains We use IntelliJ IDEA Ultimate as the Scala IDE of our choice.","title":"Sponsors"}]}